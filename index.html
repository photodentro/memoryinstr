<!doctype html> 
<!-- Copyright (C) 2018 Alkis Georgopoulos <alkisg@gmail.com>. License: GPLv3. -->
<html lang="el"> 
<head> 
  <meta charset="UTF-8" />
  <!-- Using this metatag users can't scale the page using pinchIn/out gestures on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>Παιχνίδι μνήμης</title> 
  <!--REMEMEBER TO RESTORE
  <script src="https://code.createjs.com/1.0.0/easeljs.min.js"></script>-->
  <script src="createjs-2015.11.26.min.js"></script>  
  <style type="text/css">
    /* Remove margins and HTML scrollbars */
    body, html  {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
    }
    #mainCanvas {
    padding: 0;
    margin: auto;
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    }
  </style>
</head>

<body onLoad="init();">
  <div style="border-width:10px;border-color:white;">
    <canvas id="mainCanvas" width="320" height="180">
      Your browser doesn't support HTML5!
    </canvas>
  </div>
<script>//where everything happens
  var statusText = "";
  var level = 0;
  var lvlText = 1;
  var menubar = [];
  const ratio = 16/9;
  var tiles  = [];
  var tilesNum;
  var bg;
  var resourceNames = ["01_cat.png","02_pig.png","03_bear.png","04_hippopotamus.png","05_penguin.png","06_cow.png","07_sheep.png","08_turtle.png","09_panda.png","10_chicken.png","11_redbird.png","12_wolf.png","13_monkey.png","14_fox.png","15_bluebirds.png","16_elephant.png","17_lion.png","18_gnu.png","19_bluebaby.png","20_greenbaby.png","21_frog.png","backcard.png","emptycard.png","background.svg","bar_help.svg","bar_home.svg","bar_previous.svg","bar_next.svg",];
  var numOfCards = 21;
  var resources = [];
  var resourcesLoaded = 0;
  var backCard;
  var emptyCard;
  var emptyCardsIndex = 0;

  // Internal level number is zero-based; but we display it as 1-based.
  // Levels:       0   1    2    3    4     5  
  // Card layout: 2x3 2x4  2x5  3x4  3x6   4x5   
  // Tiles number: 6   8   10   12   18    20   
  // Cards needed: 3   4    5    6    9    10
  var tilesNumArr = [ 6,  8, 10, 12, 18, 20];
  var gridXArr    = [ 3,  4,  5,  4,  6,  5];
  var gridYArr    = [ 2,  2,  2,  3,  3,  4];
  var gridX,gridY;
  var openCards = [];
  var matchedCards = [];



  function imgByName(name) {
    return resources[resourceNames.indexOf(name)];
  }
 function queueFileLoad(event) {
    resourcesLoaded++;
    statusText.text = "Φόρτωση " + parseInt(100*resourcesLoaded/resourceNames.length) + " %";
    stage.update();
    if (resourcesLoaded == resourceNames.length){
      queueComplete(event);
    }
  }
  function init(){
    console.clear();
    stage = new createjs.Stage("mainCanvas");
    stage.enableMouseOver();
     // Resource preloading
    for (var i = 0; i < resourceNames.length; i++) {
      resources[i] = new Image();
      resources[i].src = "resource/" + resourceNames[i];
      resources[i].onload = queueFileLoad;
    }
    bg = new createjs.Bitmap(imgByName("background.svg"));
    
    bg.scaleX = stage.canvas.width / bg.image.width;
    bg.scaleY = stage.canvas.height / bg.image.height;
    bg.alpha = 0.5;
    stage.addChild(bg);
    stage.update();
    window.addEventListener('resize', resize, false);
  }
 
  function queueComplete(event) {
    console.log("Finished loading resources");
    console.log("Let's get this party started!");
    backCard = new createjs.Bitmap(imgByName("backcard.png"));
    emptyCard = new createjs.Bitmap(imgByName("emptycard.png"));
    cont = new createjs.Container();
    stage.addChild(cont);
    //all tiles are initialized
    for (i = 0; i < 21; i++) {
      tiles[i] = new createjs.Bitmap(imgByName("backcard.png"));
      tiles[i].visible = false;
      var hit = new createjs.Shape();
      hit.graphics.beginFill("#000").drawRect(0, 0, emptyCard.image.width, emptyCard.image.height);
      tiles[i].hitArea = hit;

      tiles[i].addEventListener("click", function(event) {
          openCard(event.target);
      });
      cont.addChild(tiles[i]);
    }

    var onMenuClick = [onMenuHelp, onMenuHome, onMenuPrevious, onMenuNext];
    for (i = 0; i < 4; i++) {
      var menuImageStartIndex = resourceNames.indexOf('bar_help.svg');

      menubar[i] = new createjs.Bitmap(resources[menuImageStartIndex+i]);
      menubar[i].addEventListener("click", onMenuClick[i]);
      menubar[i].addEventListener("mouseover", function(event) {
        // Bring the target on top in its container, mostly for the rotation animation
        event.target.parent.setChildIndex(event.target, event.target.parent.numChildren - 1);
        event.target.scaleX = 1.2*event.target.savedscaleX;
        event.target.scaleY = 1.2*event.target.savedscaleY;
        stage.update();
      });
      menubar[i].addEventListener("mouseout", function(event) {
        event.target.scaleX = event.target.savedscaleX;
        event.target.scaleY = event.target.savedscaleY;
        stage.update();
      });
      stage.addChild(menubar[i]);
    }
    lvlText = new createjs.Text("1", "20px Arial", "white");
    lvlText.textAlign = "center";
    lvlText.textBaseline = "middle";

    stage.addChild(lvlText);
    stage.update();
    initLevel(0);
  }
  function resize() {
    // Resize the canvas element
    winratio = window.innerWidth/window.innerHeight;
    if (winratio >= ratio) {
      stage.canvas.height = window.innerHeight;
      stage.canvas.width = stage.canvas.height * ratio;
    } else {
      stage.canvas.width = window.innerWidth;
      stage.canvas.height = stage.canvas.width / ratio;
    }
    var bbs = stage.canvas.height / 10;  // bar button size
    var bbm = bbs / 5;  // bar button margin
    for (i = 0; i < 4; i++) {
      // Leave one space for the level
      if (i < 3)
        j = i;
      else
        j = i + 1;
      menubar[i].scaleX = bbs / menubar[i].image.width;
      menubar[i].scaleY = bbs / menubar[i].image.height;
      menubar[i].regX = menubar[i].image.width / 2;
      menubar[i].regY = menubar[i].image.height / 2;
      menubar[i].x = (j + 1)*bbm + bbs/2 + j*bbs;
      menubar[i].y = stage.canvas.height - bbm - bbs/2;
      // These copies are used to preserve the original scale on mouseover
      menubar[i].savedscaleX = menubar[i].scaleX;
      menubar[i].savedscaleY = menubar[i].scaleY;
    }
    lvlText.text = level + 1;
    lvlText.x = (3 + 1)*bbm + bbs/2 + 3*bbs - bbs/4;
    lvlText.y = stage.canvas.height - bbm/2 - bbs/2;
    lvlText.font = parseInt(2*bbs/2) + "px Arial";
    menubar[3].x -= bbs/2;

    
    var y_available = stage.canvas.height - bbm - bbs/2 
    var x_available = stage.canvas.width;
    
    var margin = 10 - gridY;
    var scaledHeight = (y_available - margin - (gridY-1)*margin - margin) / gridY;
    //get the scaling first
    for (var i=0; i<tilesNum; i++){
      tiles[i].scaleY = scaledHeight / imgByName('backcard.png').height;
      tiles[i].scaleX = tiles[i].scaleY;
      tiles[i].openItem.scaleX = tiles[i].scaleX;
      tiles[i].openItem.scaleY = tiles[i].scaleY;
    }
    var newWidth = tiles[0].scaleX * tiles[0].image.width;
    //compute leftrightspace
    var lrspace = (x_available - (margin + gridX*(margin + newWidth) + margin))/2;
    //position the things
    for (var i=0; i<gridY; i++){
      for (var j=0; j<gridX; j++){
        tiles[i*gridX+j].regX = tiles[i*gridX+j].image.width/2;
        tiles[i*gridX+j].regY = tiles[i*gridX+j].image.height/2;
        tiles[i*gridX+j].x = tiles[i*gridX+j].scaleX*tiles[i*gridX+j].regX + lrspace + margin + j*(margin+newWidth);
        tiles[i*gridX+j].y = tiles[i*gridX+j].scaleY*tiles[i*gridX+j].regY + margin + i*(scaledHeight+margin);
        
        //recalculate regX,regY
        tiles[i*gridX+j].openItem.regX = tiles[i*gridX+j].openItem.image.width/2;
        tiles[i*gridX+j].openItem.regY = tiles[i*gridX+j].openItem.image.height/2;
        tiles[i*gridX+j].openItem.x = tiles[i*gridX+j].x;
        tiles[i*gridX+j].openItem.y = tiles[i*gridX+j].y;
      }
    }
    
    bg.scaleX = stage.canvas.width / bg.image.width;
    bg.scaleY = stage.canvas.height / bg.image.height;
    stage.update();
  }
  function onMenuHelp(event) {
    alert("Ανοίξτε τις ίδιες κάρτες!");
  }

  function onMenuHome(event) {
    initLevel(0);
  }

  function onMenuPrevious(event) {
    initLevel((level+5) % 6);
  }

  function onMenuNext(event) {
    initLevel((level+1) % 6);
  }

  //returns the pairs of indeces shuffled
  function randomItemsIndices(num){
    var temp;
    var riArr = [];
    var ri;
    //find num/2 random indices
    ri = Math.floor(Math.random()*numOfCards);
    riArr.push(ri);//there is no reason to check
    for (var i=0; i<num/2-1; i++){
      ri = Math.floor(Math.random()*numOfCards);
      while (riArr.indexOf(ri) >= 0){
        //try again
        ri = Math.floor(Math.random()*numOfCards);
      }
      riArr.push(ri);
    }
    
    //duplicate the num/2 indices
    for (var i =0; i<num/2; i++){
      riArr.push(riArr[i]);
    }
    
    //shuffle the num indices
    for (i = 0; i < num; i++) {
      ri = Math.floor(Math.random() * num);
      temp = riArr[i];
      riArr[i] = riArr[ri];
      riArr[ri] = temp;
    }
    
    return(riArr);
  }
  function initLevel(newLevel){
    var riArr;
    level = newLevel;
    tilesNum = tilesNumArr[level];
    gridX = gridXArr[level];
    gridY = gridYArr[level];
    for (var i = 0; i<matchedCards.length; i++){
      tiles[matchedCards[i]].openItem.visible = false;
    }
    for (var i = 0; i<openCards.length; i++){
      tiles[openCards[i]].openItem.visible = false;
    }
    stage.update();
    openCards = [];
    matchedCards = [];
    riArr = randomItemsIndices(tilesNum);
    for (var i=0; i<tilesNum; i++){
      tiles[i].image = backCard.image;
      tiles[i].openItem = new createjs.Bitmap(resources[riArr[i]]);
      tiles[i].openItemIndex = riArr[i];
      tiles[i].openItem.visible = false;
    }
    for (var i = 0; i < 21; i++) {
      tiles[i].visible = i < tilesNum;
    }
    resize();
  }

  function openCard(t){
    ci = tiles.indexOf(t);
    var nextLevel = checkGame(ci);
    t.image = emptyCard.image;
    //show item of card
    t.openItem.visible = true;
    cont.addChild(t.openItem);
    cont.setChildIndex(t.openItem,cont.numChildren-1);
    //update list of open cards
    stage.update();
    if (nextLevel){
      setTimeout(onMenuNext, 2000);
    }
  }

  function closeCard(t){
    ci = tiles.indexOf(t);
    checkGame(ci);
    t.image = backCard.image;
    //show item of card
    t.openItem.visible = false;
    //update list of open cards
    stage.update();

  }
  function checkGame(ci){
    console.log(openCards[0],openCards[1]);
    console.log(matchedCards[0],matchedCards[1],matchedCards[2],matchedCards[3],matchedCards[4],matchedCards[5]);

    //if it's already open don't care
    if (openCards.indexOf(ci)>=0){
      return(false);
    }
    //if there is no open unmatched card
    if (openCards.length == 0){
      openCards.push(ci);
      return(false);
    }
    //if there is one other open unmatched card
    if (openCards.length == 1){
      //see if it matches
      if (tiles[openCards[0]].openItemIndex == tiles[ci].openItemIndex){
        matchedCards.push(openCards[0],ci);
        openCards = [];}
      else{
          openCards.push(ci);
          return(false);
      }
      if (matchedCards.length == tilesNum){
          return(true);
      }
      else{
        return(false);
      }
    }
  //if there are two unmatched cards on screen
  if (openCards.length == 2){
    closeCard(tiles[openCards[0]]);
    closeCard(tiles[openCards[1]]);
    //only the current card is now open
    openCards = [ci];
  }
  }
</script>
</body>
</html>

